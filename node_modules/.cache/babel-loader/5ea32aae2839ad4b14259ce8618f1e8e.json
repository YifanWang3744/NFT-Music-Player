{"ast":null,"code":"\"use strict\";\n/**\r\n *  BigNumber\r\n *\r\n *  A wrapper around the BN.js object. We use the BN.js library\r\n *  because it is used by elliptic, so it is required regardless.\r\n *\r\n */\n\nimport _BN from \"bn.js\";\nvar BN = _BN.BN;\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n} // Only warn about passing 10 into radix once\n\nlet _warnedToStringRadix = false;\nexport class BigNumber {\n  constructor(constructorGuard, hex) {\n    logger.checkNew(new.target, BigNumber);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n\n  fromTwos(value) {\n    return toBigNumber(toBN(this).fromTwos(value));\n  }\n\n  toTwos(value) {\n    return toBigNumber(toBN(this).toTwos(value));\n  }\n\n  abs() {\n    if (this._hex[0] === \"-\") {\n      return BigNumber.from(this._hex.substring(1));\n    }\n\n    return this;\n  }\n\n  add(other) {\n    return toBigNumber(toBN(this).add(toBN(other)));\n  }\n\n  sub(other) {\n    return toBigNumber(toBN(this).sub(toBN(other)));\n  }\n\n  div(other) {\n    const o = BigNumber.from(other);\n\n    if (o.isZero()) {\n      throwFault(\"division by zero\", \"div\");\n    }\n\n    return toBigNumber(toBN(this).div(toBN(other)));\n  }\n\n  mul(other) {\n    return toBigNumber(toBN(this).mul(toBN(other)));\n  }\n\n  mod(other) {\n    const value = toBN(other);\n\n    if (value.isNeg()) {\n      throwFault(\"cannot modulo negative values\", \"mod\");\n    }\n\n    return toBigNumber(toBN(this).umod(value));\n  }\n\n  pow(other) {\n    const value = toBN(other);\n\n    if (value.isNeg()) {\n      throwFault(\"cannot raise to negative values\", \"pow\");\n    }\n\n    return toBigNumber(toBN(this).pow(value));\n  }\n\n  and(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"cannot 'and' negative values\", \"and\");\n    }\n\n    return toBigNumber(toBN(this).and(value));\n  }\n\n  or(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"cannot 'or' negative values\", \"or\");\n    }\n\n    return toBigNumber(toBN(this).or(value));\n  }\n\n  xor(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"cannot 'xor' negative values\", \"xor\");\n    }\n\n    return toBigNumber(toBN(this).xor(value));\n  }\n\n  mask(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"cannot mask negative values\", \"mask\");\n    }\n\n    return toBigNumber(toBN(this).maskn(value));\n  }\n\n  shl(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"cannot shift negative values\", \"shl\");\n    }\n\n    return toBigNumber(toBN(this).shln(value));\n  }\n\n  shr(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"cannot shift negative values\", \"shr\");\n    }\n\n    return toBigNumber(toBN(this).shrn(value));\n  }\n\n  eq(other) {\n    return toBN(this).eq(toBN(other));\n  }\n\n  lt(other) {\n    return toBN(this).lt(toBN(other));\n  }\n\n  lte(other) {\n    return toBN(this).lte(toBN(other));\n  }\n\n  gt(other) {\n    return toBN(this).gt(toBN(other));\n  }\n\n  gte(other) {\n    return toBN(this).gte(toBN(other));\n  }\n\n  isNegative() {\n    return this._hex[0] === \"-\";\n  }\n\n  isZero() {\n    return toBN(this).isZero();\n  }\n\n  toNumber() {\n    try {\n      return toBN(this).toNumber();\n    } catch (error) {\n      throwFault(\"overflow\", \"toNumber\", this.toString());\n    }\n\n    return null;\n  }\n\n  toBigInt() {\n    try {\n      return BigInt(this.toString());\n    } catch (e) {}\n\n    return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n      value: this.toString()\n    });\n  }\n\n  toString() {\n    // Lots of people expect this, which we do not support, so check (See: #889)\n    if (arguments.length > 0) {\n      if (arguments[0] === 10) {\n        if (!_warnedToStringRadix) {\n          _warnedToStringRadix = true;\n          logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n        }\n      } else if (arguments[0] === 16) {\n        logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      } else {\n        logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n    }\n\n    return toBN(this).toString(10);\n  }\n\n  toHexString() {\n    return this._hex;\n  }\n\n  toJSON(key) {\n    return {\n      type: \"BigNumber\",\n      hex: this.toHexString()\n    };\n  }\n\n  static from(value) {\n    if (value instanceof BigNumber) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      if (value.match(/^-?0x[0-9a-f]+$/i)) {\n        return new BigNumber(_constructorGuard, toHex(value));\n      }\n\n      if (value.match(/^-?[0-9]+$/)) {\n        return new BigNumber(_constructorGuard, toHex(new BN(value)));\n      }\n\n      return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n    }\n\n    if (typeof value === \"number\") {\n      if (value % 1) {\n        throwFault(\"underflow\", \"BigNumber.from\", value);\n      }\n\n      if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n        throwFault(\"overflow\", \"BigNumber.from\", value);\n      }\n\n      return BigNumber.from(String(value));\n    }\n\n    const anyValue = value;\n\n    if (typeof anyValue === \"bigint\") {\n      return BigNumber.from(anyValue.toString());\n    }\n\n    if (isBytes(anyValue)) {\n      return BigNumber.from(hexlify(anyValue));\n    }\n\n    if (anyValue) {\n      // Hexable interface (takes priority)\n      if (anyValue.toHexString) {\n        const hex = anyValue.toHexString();\n\n        if (typeof hex === \"string\") {\n          return BigNumber.from(hex);\n        }\n      } else {\n        // For now, handle legacy JSON-ified values (goes away in v6)\n        let hex = anyValue._hex; // New-form JSON\n\n        if (hex == null && anyValue.type === \"BigNumber\") {\n          hex = anyValue.hex;\n        }\n\n        if (typeof hex === \"string\") {\n          if (isHexString(hex) || hex[0] === \"-\" && isHexString(hex.substring(1))) {\n            return BigNumber.from(hex);\n          }\n        }\n      }\n    }\n\n    return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n  }\n\n  static isBigNumber(value) {\n    return !!(value && value._isBigNumber);\n  }\n\n} // Normalize the hex string\n\nfunction toHex(value) {\n  // For BN, call on the hex string\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  } // If negative, prepend the negative sign to the normalized positive value\n\n\n  if (value[0] === \"-\") {\n    // Strip off the negative sign\n    value = value.substring(1); // Cannot have multiple negative signs (e.g. \"--0x04\")\n\n    if (value[0] === \"-\") {\n      logger.throwArgumentError(\"invalid hex\", \"value\", value);\n    } // Call toHex on the positive component\n\n\n    value = toHex(value); // Do not allow \"-0x00\"\n\n    if (value === \"0x00\") {\n      return value;\n    } // Negate the value\n\n\n    return \"-\" + value;\n  } // Add a \"0x\" prefix if missing\n\n\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  } // Normalize zero\n\n\n  if (value === \"0x\") {\n    return \"0x00\";\n  } // Make the string even length\n\n\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  } // Trim to smallest even-length string\n\n\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n\n  return value;\n}\n\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value) {\n  const hex = BigNumber.from(value).toHexString();\n\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n\n  return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value != null) {\n    params.value = value;\n  }\n\n  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n} // value should have no prefix\n\n\nexport function _base36To16(value) {\n  return new BN(value, 36).toString(16);\n} // value should have no prefix\n\nexport function _base16To36(value) {\n  return new BN(value, 16).toString(36);\n}","map":{"version":3,"mappings":"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","names":["_BN","BN","hexlify","isBytes","isHexString","Logger","version","logger","_constructorGuard","MAX_SAFE","isBigNumberish","value","BigNumber","isBigNumber","match","_warnedToStringRadix","constructor","constructorGuard","hex","checkNew","new","target","throwError","errors","UNSUPPORTED_OPERATION","operation","_hex","_isBigNumber","Object","freeze","fromTwos","toBigNumber","toBN","toTwos","abs","from","substring","add","other","sub","div","o","isZero","throwFault","mul","mod","isNeg","umod","pow","and","isNegative","or","xor","mask","maskn","shl","shln","shr","shrn","eq","lt","lte","gt","gte","toNumber","error","toString","toBigInt","BigInt","e","arguments","length","warn","UNEXPECTED_ARGUMENT","toHexString","toJSON","key","type","toHex","throwArgumentError","String","anyValue","fault","params","NUMERIC_FAULT","_base36To16","_base16To36"],"sources":["E:\\6883proj\\6883project\\node_modules\\@ethersproject\\bignumber\\src.ts\\bignumber.ts"],"sourcesContent":["\"use strict\";\r\n\r\n/**\r\n *  BigNumber\r\n *\r\n *  A wrapper around the BN.js object. We use the BN.js library\r\n *  because it is used by elliptic, so it is required regardless.\r\n *\r\n */\r\n\r\nimport _BN from \"bn.js\";\r\nimport BN = _BN.BN;\r\n\r\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nconst _constructorGuard = { };\r\n\r\nconst MAX_SAFE = 0x1fffffffffffff;\r\n\r\n\r\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\r\n\r\nexport function isBigNumberish(value: any): value is BigNumberish {\r\n    return (value != null) && (\r\n        BigNumber.isBigNumber(value) ||\r\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\r\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\r\n        isHexString(value) ||\r\n        (typeof(value) === \"bigint\") ||\r\n        isBytes(value)\r\n    );\r\n}\r\n\r\n// Only warn about passing 10 into radix once\r\nlet _warnedToStringRadix = false;\r\n\r\nexport class BigNumber implements Hexable {\r\n    readonly _hex: string;\r\n    readonly _isBigNumber: boolean;\r\n\r\n    constructor(constructorGuard: any, hex: string) {\r\n        logger.checkNew(new.target, BigNumber);\r\n\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new (BigNumber)\"\r\n            });\r\n        }\r\n\r\n        this._hex = hex;\r\n        this._isBigNumber = true;\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    fromTwos(value: number): BigNumber {\r\n        return toBigNumber(toBN(this).fromTwos(value));\r\n    }\r\n\r\n    toTwos(value: number): BigNumber {\r\n        return toBigNumber(toBN(this).toTwos(value));\r\n    }\r\n\r\n    abs(): BigNumber {\r\n        if (this._hex[0] === \"-\") {\r\n            return BigNumber.from(this._hex.substring(1));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    add(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).add(toBN(other)));\r\n    }\r\n\r\n    sub(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).sub(toBN(other)));\r\n    }\r\n\r\n    div(other: BigNumberish): BigNumber {\r\n        const o = BigNumber.from(other);\r\n        if (o.isZero()) {\r\n            throwFault(\"division by zero\", \"div\");\r\n        }\r\n        return toBigNumber(toBN(this).div(toBN(other)));\r\n    }\r\n\r\n    mul(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).mul(toBN(other)));\r\n    }\r\n\r\n    mod(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"cannot modulo negative values\", \"mod\");\r\n        }\r\n        return toBigNumber(toBN(this).umod(value));\r\n    }\r\n\r\n    pow(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"cannot raise to negative values\", \"pow\");\r\n        }\r\n        return toBigNumber(toBN(this).pow(value));\r\n    }\r\n\r\n    and(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'and' negative values\", \"and\");\r\n        }\r\n        return toBigNumber(toBN(this).and(value));\r\n    }\r\n\r\n    or(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'or' negative values\", \"or\");\r\n        }\r\n        return toBigNumber(toBN(this).or(value));\r\n    }\r\n\r\n    xor(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\r\n        }\r\n        return toBigNumber(toBN(this).xor(value));\r\n    }\r\n\r\n    mask(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot mask negative values\", \"mask\");\r\n        }\r\n        return toBigNumber(toBN(this).maskn(value));\r\n    }\r\n\r\n    shl(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot shift negative values\", \"shl\");\r\n        }\r\n        return toBigNumber(toBN(this).shln(value));\r\n    }\r\n\r\n    shr(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"cannot shift negative values\", \"shr\");\r\n        }\r\n        return toBigNumber(toBN(this).shrn(value));\r\n    }\r\n\r\n    eq(other: BigNumberish): boolean {\r\n        return toBN(this).eq(toBN(other));\r\n    }\r\n\r\n    lt(other: BigNumberish): boolean {\r\n        return toBN(this).lt(toBN(other));\r\n    }\r\n\r\n    lte(other: BigNumberish): boolean {\r\n        return toBN(this).lte(toBN(other));\r\n    }\r\n\r\n    gt(other: BigNumberish): boolean {\r\n        return toBN(this).gt(toBN(other));\r\n   }\r\n\r\n    gte(other: BigNumberish): boolean {\r\n        return toBN(this).gte(toBN(other));\r\n    }\r\n\r\n    isNegative(): boolean {\r\n        return (this._hex[0] === \"-\");\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return toBN(this).isZero();\r\n    }\r\n\r\n    toNumber(): number {\r\n        try {\r\n            return toBN(this).toNumber();\r\n        } catch (error) {\r\n            throwFault(\"overflow\", \"toNumber\", this.toString());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    toBigInt(): bigint {\r\n        try {\r\n            return BigInt(this.toString());\r\n        } catch (e) { }\r\n\r\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            value: this.toString()\r\n        });\r\n    }\r\n\r\n    toString(): string {\r\n        // Lots of people expect this, which we do not support, so check (See: #889)\r\n        if (arguments.length > 0) {\r\n            if (arguments[0] === 10) {\r\n                if (!_warnedToStringRadix) {\r\n                    _warnedToStringRadix = true;\r\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\r\n                }\r\n            } else if (arguments[0] === 16) {\r\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\r\n            } else {\r\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\r\n            }\r\n        }\r\n        return toBN(this).toString(10);\r\n    }\r\n\r\n    toHexString(): string {\r\n        return this._hex;\r\n    }\r\n\r\n    toJSON(key?: string): any {\r\n        return { type: \"BigNumber\", hex: this.toHexString() };\r\n    }\r\n\r\n    static from(value: any): BigNumber {\r\n        if (value instanceof BigNumber) { return value; }\r\n\r\n        if (typeof(value) === \"string\") {\r\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\r\n                return new BigNumber(_constructorGuard, toHex(value));\r\n            }\r\n\r\n            if (value.match(/^-?[0-9]+$/)) {\r\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\r\n            }\r\n\r\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\r\n        }\r\n\r\n        if (typeof(value) === \"number\") {\r\n            if (value % 1) {\r\n                throwFault(\"underflow\", \"BigNumber.from\", value);\r\n            }\r\n\r\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\r\n                throwFault(\"overflow\", \"BigNumber.from\", value);\r\n            }\r\n\r\n            return BigNumber.from(String(value));\r\n        }\r\n\r\n        const anyValue = <any>value;\r\n\r\n        if (typeof(anyValue) === \"bigint\") {\r\n            return BigNumber.from(anyValue.toString());\r\n        }\r\n\r\n        if (isBytes(anyValue)) {\r\n            return BigNumber.from(hexlify(anyValue));\r\n        }\r\n\r\n        if (anyValue) {\r\n\r\n            // Hexable interface (takes priority)\r\n            if (anyValue.toHexString) {\r\n                const hex = anyValue.toHexString();\r\n                if (typeof(hex) === \"string\") {\r\n                    return BigNumber.from(hex);\r\n                }\r\n\r\n            } else {\r\n                // For now, handle legacy JSON-ified values (goes away in v6)\r\n                let hex = anyValue._hex;\r\n\r\n                // New-form JSON\r\n                if (hex == null && anyValue.type === \"BigNumber\") {\r\n                    hex = anyValue.hex;\r\n                }\r\n\r\n                if (typeof(hex) === \"string\") {\r\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\r\n                        return BigNumber.from(hex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\r\n    }\r\n\r\n    static isBigNumber(value: any): value is BigNumber {\r\n        return !!(value && value._isBigNumber);\r\n    }\r\n}\r\n\r\n// Normalize the hex string\r\nfunction toHex(value: string | BN): string {\r\n\r\n    // For BN, call on the hex string\r\n    if (typeof(value) !== \"string\") {\r\n        return toHex(value.toString(16));\r\n    }\r\n\r\n    // If negative, prepend the negative sign to the normalized positive value\r\n    if (value[0] === \"-\") {\r\n        // Strip off the negative sign\r\n        value = value.substring(1);\r\n\r\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\r\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\r\n\r\n        // Call toHex on the positive component\r\n        value = toHex(value);\r\n\r\n        // Do not allow \"-0x00\"\r\n        if (value === \"0x00\") { return value; }\r\n\r\n        // Negate the value\r\n        return \"-\" + value;\r\n    }\r\n\r\n    // Add a \"0x\" prefix if missing\r\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\r\n\r\n    // Normalize zero\r\n    if (value === \"0x\") { return \"0x00\"; }\r\n\r\n    // Make the string even length\r\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\r\n\r\n    // Trim to smallest even-length string\r\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\r\n        value = \"0x\" + value.substring(4);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nfunction toBigNumber(value: BN): BigNumber {\r\n    return BigNumber.from(toHex(value));\r\n}\r\n\r\nfunction toBN(value: BigNumberish): BN {\r\n    const hex = BigNumber.from(value).toHexString();\r\n    if (hex[0] === \"-\") {\r\n        return (new BN(\"-\" + hex.substring(3), 16));\r\n    }\r\n    return new BN(hex.substring(2), 16);\r\n}\r\n\r\nfunction throwFault(fault: string, operation: string, value?: any): never {\r\n    const params: any = { fault: fault, operation: operation };\r\n    if (value != null) { params.value = value; }\r\n\r\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\r\n}\r\n\r\n// value should have no prefix\r\nexport function _base36To16(value: string): string {\r\n    return (new BN(value, 36)).toString(16);\r\n}\r\n\r\n// value should have no prefix\r\nexport function _base16To36(value: string): string {\r\n    return (new BN(value, 16)).toString(36);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}