{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n  password = arrayify(password);\n  salt = arrayify(salt);\n  let hLen;\n  let l = 1;\n  const DK = new Uint8Array(keylen);\n  const block1 = new Uint8Array(salt.length + 4);\n  block1.set(salt); //salt.copy(block1, 0, 0, salt.length)\n\n  let r;\n  let T;\n\n  for (let i = 1; i <= l; i++) {\n    //block1.writeUInt32BE(i, salt.length)\n    block1[salt.length] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i & 0xff; //let U = createHmac(password).update(block1).digest();\n\n    let U = arrayify(computeHmac(hashAlgorithm, password, block1));\n\n    if (!hLen) {\n      hLen = U.length;\n      T = new Uint8Array(hLen);\n      l = Math.ceil(keylen / hLen);\n      r = keylen - (l - 1) * hLen;\n    } //U.copy(T, 0, 0, hLen)\n\n\n    T.set(U);\n\n    for (let j = 1; j < iterations; j++) {\n      //U = createHmac(password).update(U).digest();\n      U = arrayify(computeHmac(hashAlgorithm, password, U));\n\n      for (let k = 0; k < hLen; k++) T[k] ^= U[k];\n    }\n\n    const destPos = (i - 1) * hLen;\n    const len = i === l ? r : hLen; //T.copy(DK, destPos, 0, len)\n\n    DK.set(arrayify(T).slice(0, len), destPos);\n  }\n\n  return hexlify(DK);\n}","map":{"version":3,"mappings":"AAAA;;AAEA,SAASA,QAAT,EAA8BC,OAA9B,QAA6C,sBAA7C;AACA,SAASC,WAAT,QAAgD,qBAAhD;AAEA,OAAM,SAAUC,MAAV,CAAiBC,QAAjB,EAAsCC,IAAtC,EAAuDC,UAAvD,EAA2EC,MAA3E,EAA2FC,aAA3F,EAAgH;AAClHJ,UAAQ,GAAGJ,QAAQ,CAACI,QAAD,CAAnB;AACAC,MAAI,GAAGL,QAAQ,CAACK,IAAD,CAAf;AACA,MAAII,IAAJ;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,QAAMC,EAAE,GAAG,IAAIC,UAAJ,CAAeL,MAAf,CAAX;AACA,QAAMM,MAAM,GAAG,IAAID,UAAJ,CAAeP,IAAI,CAACS,MAAL,GAAc,CAA7B,CAAf;AACAD,QAAM,CAACE,GAAP,CAAWV,IAAX,EAPkH,CAQlH;;AAEA,MAAIW,CAAJ;AACA,MAAIC,CAAJ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIR,CAArB,EAAwBQ,CAAC,EAAzB,EAA6B;AACzB;AACAL,UAAM,CAACR,IAAI,CAACS,MAAN,CAAN,GAAuBI,CAAC,IAAI,EAAN,GAAY,IAAlC;AACAL,UAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA2BI,CAAC,IAAI,EAAN,GAAY,IAAtC;AACAL,UAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA2BI,CAAC,IAAI,CAAN,GAAW,IAArC;AACAL,UAAM,CAACR,IAAI,CAACS,MAAL,GAAc,CAAf,CAAN,GAA0BI,CAAC,GAAG,IAA9B,CALyB,CAOzB;;AACA,QAAIC,CAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAArB,EAAoCJ,QAApC,EAA8CS,MAA9C,CAAZ,CAAhB;;AAEA,QAAI,CAACJ,IAAL,EAAW;AACPA,UAAI,GAAGU,CAAC,CAACL,MAAT;AACAG,OAAC,GAAG,IAAIL,UAAJ,CAAeH,IAAf,CAAJ;AACAC,OAAC,GAAGU,IAAI,CAACC,IAAL,CAAUd,MAAM,GAAGE,IAAnB,CAAJ;AACAO,OAAC,GAAGT,MAAM,GAAG,CAACG,CAAC,GAAG,CAAL,IAAUD,IAAvB;AACH,KAfwB,CAiBzB;;;AACAQ,KAAC,CAACF,GAAF,CAAMI,CAAN;;AAGA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,UAApB,EAAgCgB,CAAC,EAAjC,EAAqC;AACjC;AACAH,OAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAArB,EAAoCJ,QAApC,EAA8Ce,CAA9C,CAAZ,CAAZ;;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,IAApB,EAA0Bc,CAAC,EAA3B,EAA+BN,CAAC,CAACM,CAAD,CAAD,IAAQJ,CAAC,CAACI,CAAD,CAAT;AAClC;;AAGD,UAAMC,OAAO,GAAG,CAACN,CAAC,GAAG,CAAL,IAAUT,IAA1B;AACA,UAAMgB,GAAG,GAAIP,CAAC,KAAKR,CAAN,GAAUM,CAAV,GAAcP,IAA3B,CA7ByB,CA8BzB;;AACAE,MAAE,CAACI,GAAH,CAAOf,QAAQ,CAACiB,CAAD,CAAR,CAAYS,KAAZ,CAAkB,CAAlB,EAAqBD,GAArB,CAAP,EAAkCD,OAAlC;AACH;;AAED,SAAOvB,OAAO,CAACU,EAAD,CAAd;AACH","names":["arrayify","hexlify","computeHmac","pbkdf2","password","salt","iterations","keylen","hashAlgorithm","hLen","l","DK","Uint8Array","block1","length","set","r","T","i","U","Math","ceil","j","k","destPos","len","slice"],"sources":["E:\\6883proj\\6883project\\node_modules\\@ethersproject\\pbkdf2\\src.ts\\browser-pbkdf2.ts"],"sourcesContent":["\"use strict\";\r\n\r\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\r\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\r\n\r\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\r\n    password = arrayify(password);\r\n    salt = arrayify(salt);\r\n    let hLen;\r\n    let l = 1;\r\n    const DK = new Uint8Array(keylen)\r\n    const block1 = new Uint8Array(salt.length + 4)\r\n    block1.set(salt);\r\n    //salt.copy(block1, 0, 0, salt.length)\r\n\r\n    let r: number;\r\n    let T: Uint8Array;\r\n\r\n    for (let i = 1; i <= l; i++) {\r\n        //block1.writeUInt32BE(i, salt.length)\r\n        block1[salt.length] = (i >> 24) & 0xff;\r\n        block1[salt.length + 1] = (i >> 16) & 0xff;\r\n        block1[salt.length + 2] = (i >> 8) & 0xff;\r\n        block1[salt.length + 3] = i & 0xff;\r\n\r\n        //let U = createHmac(password).update(block1).digest();\r\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\r\n\r\n        if (!hLen) {\r\n            hLen = U.length\r\n            T = new Uint8Array(hLen)\r\n            l = Math.ceil(keylen / hLen)\r\n            r = keylen - (l - 1) * hLen\r\n        }\r\n\r\n        //U.copy(T, 0, 0, hLen)\r\n        T.set(U);\r\n\r\n\r\n        for (let j = 1; j < iterations; j++) {\r\n            //U = createHmac(password).update(U).digest();\r\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\r\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\r\n        }\r\n\r\n\r\n        const destPos = (i - 1) * hLen\r\n        const len = (i === l ? r : hLen)\r\n        //T.copy(DK, destPos, 0, len)\r\n        DK.set(arrayify(T).slice(0, len), destPos);\r\n    }\r\n\r\n    return hexlify(DK)\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}