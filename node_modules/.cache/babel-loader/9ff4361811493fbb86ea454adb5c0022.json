{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() {\n  return new Date().getTime();\n} // Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\n\n\nfunction checkNetworks(networks) {\n  let result = null;\n\n  for (let i = 0; i < networks.length; i++) {\n    const network = networks[i]; // Null! We do not know our network; bail.\n\n    if (network == null) {\n      return null;\n    }\n\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n\n  return result;\n}\n\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  const middle = Math.floor(values.length / 2); // Odd length; take the middle\n\n  if (values.length % 2) {\n    return values[middle];\n  } // Even length; take the average of the two middle\n\n\n  const a = values[middle - 1],\n        b = values[middle];\n\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n\n  return (a + b) / 2;\n}\n\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(i => serialize(i)));\n  } else if (typeof value === \"object\") {\n    const keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(key => {\n      let v = value[key];\n\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n\n  throw new Error(\"unknown value type: \" + typeof value);\n} // Next request ID to use for emitting debug info\n\n\nlet nextRid = 1;\n;\n\nfunction stall(duration) {\n  let cancel = null;\n  let timer = null;\n  let promise = new Promise(resolve => {\n    cancel = function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n\n      resolve();\n    };\n\n    timer = setTimeout(cancel, duration);\n  });\n\n  const wait = func => {\n    promise = promise.then(func);\n    return promise;\n  };\n\n  function getPromise() {\n    return promise;\n  }\n\n  return {\n    cancel,\n    getPromise,\n    wait\n  };\n}\n\nconst ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nconst ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\n\nfunction exposeDebugConfig(config, now) {\n  const result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: () => config.provider\n  });\n\n  if (config.start) {\n    result.start = config.start;\n  }\n\n  if (now) {\n    result.duration = now - config.start;\n  }\n\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n\n  return result;\n}\n\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    const tally = {};\n    configs.forEach(c => {\n      const value = normalize(c.result);\n\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n\n      tally[value].count++;\n    }); // Check for a quorum on any given result\n\n    const keys = Object.keys(tally);\n\n    for (let i = 0; i < keys.length; i++) {\n      const check = tally[keys[i]];\n\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    } // No quroum\n\n\n    return undefined;\n  };\n}\n\nfunction getProcessFunc(provider, method, params) {\n  let normalize = serialize;\n\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        const values = configs.map(c => c.result); // Get the median block number\n\n        let blockNumber = median(configs.map(c => c.result), 2);\n\n        if (blockNumber == null) {\n          return undefined;\n        }\n\n        blockNumber = Math.ceil(blockNumber); // If the next block height is present, its prolly safe to use\n\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        } // Don't ever roll back the blockNumber\n\n\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n\n        return provider._highestBlockNumber;\n      };\n\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        const values = configs.map(c => c.result);\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(c => c.result));\n      };\n    // No additional normalizing required; serialize is enough\n\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function (tx) {\n        if (tx == null) {\n          return null;\n        }\n\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(tx => {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          return serialize(block);\n        };\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unknown method: \" + method);\n  } // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n\n\n  return normalizedTally(normalize, provider.quorum);\n} // If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\n\n\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const provider = config.provider;\n\n    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {\n      return provider;\n    }\n\n    return poll(() => {\n      return new Promise((resolve, reject) => {\n        setTimeout(function () {\n          // We are synced\n          if (provider.blockNumber >= blockNumber) {\n            return resolve(provider);\n          } // We're done; just quit\n\n\n          if (config.cancelled) {\n            return resolve(null);\n          } // Try again, next block\n\n\n          return resolve(undefined);\n        }, 0);\n      });\n    }, {\n      oncePoll: provider\n    });\n  });\n}\n\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let provider = config.provider;\n\n    switch (method) {\n      case \"getBlockNumber\":\n      case \"getGasPrice\":\n        return provider[method]();\n\n      case \"getEtherPrice\":\n        if (provider.getEtherPrice) {\n          return provider.getEtherPrice();\n        }\n\n        break;\n\n      case \"getBalance\":\n      case \"getTransactionCount\":\n      case \"getCode\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[method](params.address, params.blockTag || \"latest\");\n\n      case \"getStorageAt\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n\n      case \"getBlock\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash);\n\n      case \"call\":\n      case \"estimateGas\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[method](params.transaction);\n\n      case \"getTransaction\":\n      case \"getTransactionReceipt\":\n        return provider[method](params.transactionHash);\n\n      case \"getLogs\":\n        {\n          let filter = params.filter;\n\n          if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {\n            provider = yield waitForSync(config, currentBlockNumber);\n          }\n\n          return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n      method: method,\n      params: params\n    });\n  });\n}\n\nexport class FallbackProvider extends BaseProvider {\n  constructor(providers, quorum) {\n    logger.checkNew(new.target, FallbackProvider);\n\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n\n    const providerConfigs = providers.map((configOrProvider, index) => {\n      if (Provider.isProvider(configOrProvider)) {\n        const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        const priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout,\n          priority\n        });\n      }\n\n      const config = shallowCopy(configOrProvider);\n\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n\n      const weight = config.weight;\n\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n      }\n\n      return Object.freeze(config);\n    });\n    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);\n\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    } // Are all providers' networks are known\n\n\n    let networkOrReady = checkNetworks(providerConfigs.map(c => c.provider.network)); // Not all networks are known; we must stall\n\n    if (networkOrReady == null) {\n      networkOrReady = new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n\n    super(networkOrReady); // Preserve a copy, so we do not get mutated\n\n    defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(this, \"quorum\", quorum);\n    this._highestBlockNumber = -1;\n  }\n\n  detectNetwork() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const networks = yield Promise.all(this.providerConfigs.map(c => c.provider.getNetwork()));\n      return checkNetworks(networks);\n    });\n  }\n\n  perform(method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sending transactions is special; always broadcast it to all backends\n      if (method === \"sendTransaction\") {\n        const results = yield Promise.all(this.providerConfigs.map(c => {\n          return c.provider.sendTransaction(params.signedTransaction).then(result => {\n            return result.hash;\n          }, error => {\n            return error;\n          });\n        })); // Any success is good enough (other errors are likely \"already seen\" errors\n\n        for (let i = 0; i < results.length; i++) {\n          const result = results[i];\n\n          if (typeof result === \"string\") {\n            return result;\n          }\n        } // They were all an error; pick the first error\n\n\n        throw results[0];\n      } // We need to make sure we are in sync with our backends, so we need\n      // to know this before we can make a lot of calls\n\n\n      if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n        yield this.getBlockNumber();\n      }\n\n      const processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n      // shallowCopy them since we will store the result in them too\n\n      const configs = shuffled(this.providerConfigs.map(shallowCopy));\n      configs.sort((a, b) => a.priority - b.priority);\n      const currentBlockNumber = this._highestBlockNumber;\n      let i = 0;\n      let first = true;\n\n      while (true) {\n        const t0 = now(); // Compute the inflight weight (exclude anything past)\n\n        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0); // Start running enough to meet quorum\n\n        while (inflightWeight < this.quorum && i < configs.length) {\n          const config = configs[i++];\n          const rid = nextRid++;\n          config.start = now();\n          config.staller = stall(config.stallTimeout);\n          config.staller.wait(() => {\n            config.staller = null;\n          });\n          config.runner = getRunner(config, currentBlockNumber, method, params).then(result => {\n            config.done = true;\n            config.result = result;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          }, error => {\n            config.done = true;\n            config.error = error;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          });\n\n          if (this.listenerCount(\"debug\")) {\n            this.emit(\"debug\", {\n              action: \"request\",\n              rid: rid,\n              backend: exposeDebugConfig(config, null),\n              request: {\n                method: method,\n                params: deepCopy(params)\n              },\n              provider: this\n            });\n          }\n\n          inflightWeight += config.weight;\n        } // Wait for anything meaningful to finish or stall out\n\n\n        const waiting = [];\n        configs.forEach(c => {\n          if (c.done || !c.runner) {\n            return;\n          }\n\n          waiting.push(c.runner);\n\n          if (c.staller) {\n            waiting.push(c.staller.getPromise());\n          }\n        });\n\n        if (waiting.length) {\n          yield Promise.race(waiting);\n        } // Check the quorum and process the results; the process function\n        // may additionally decide the quorum is not met\n\n\n        const results = configs.filter(c => c.done && c.error == null);\n\n        if (results.length >= this.quorum) {\n          const result = processFunc(results);\n\n          if (result !== undefined) {\n            // Shut down any stallers\n            configs.forEach(c => {\n              if (c.staller) {\n                c.staller.cancel();\n              }\n\n              c.cancelled = true;\n            });\n            return result;\n          }\n\n          if (!first) {\n            yield stall(100).getPromise();\n          }\n\n          first = false;\n        } // No result, check for errors that should be forwarded\n\n\n        const errors = configs.reduce((accum, c) => {\n          if (!c.done || c.error == null) {\n            return accum;\n          }\n\n          const code = c.error.code;\n\n          if (ForwardErrors.indexOf(code) >= 0) {\n            if (!accum[code]) {\n              accum[code] = {\n                error: c.error,\n                weight: 0\n              };\n            }\n\n            accum[code].weight += c.weight;\n          }\n\n          return accum;\n        }, {});\n        Object.keys(errors).forEach(errorCode => {\n          const tally = errors[errorCode];\n\n          if (tally.weight < this.quorum) {\n            return;\n          } // Shut down any stallers\n\n\n          configs.forEach(c => {\n            if (c.staller) {\n              c.staller.cancel();\n            }\n\n            c.cancelled = true;\n          });\n          const e = tally.error;\n          const props = {};\n          ForwardProperties.forEach(name => {\n            if (e[name] == null) {\n              return;\n            }\n\n            props[name] = e[name];\n          });\n          logger.throwError(e.reason || e.message, errorCode, props);\n        }); // All configs have run to completion; we will never get more data\n\n        if (configs.filter(c => !c.done).length === 0) {\n          break;\n        }\n      } // Shut down any stallers; shouldn't be any\n\n\n      configs.forEach(c => {\n        if (c.staller) {\n          c.staller.cancel();\n        }\n\n        c.cancelled = true;\n      });\n      return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n        method: method,\n        params: params,\n        //results: configs.map((c) => c.result),\n        //errors: configs.map((c) => c.error),\n        results: configs.map(c => exposeDebugConfig(c)),\n        provider: this\n      });\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Provider","BigNumber","isHexString","deepCopy","defineReadOnly","shallowCopy","shuffled","poll","BaseProvider","isCommunityResource","Logger","version","logger","now","Date","getTime","checkNetworks","networks","result","i","length","network","name","chainId","ensAddress","throwArgumentError","median","values","maxDelta","slice","sort","middle","Math","floor","a","b","abs","serialize","value","JSON","stringify","isBigNumber","toString","Array","isArray","map","keys","Object","key","v","join","Error","nextRid","stall","duration","cancel","timer","promise","Promise","resolve","clearTimeout","setTimeout","wait","func","then","getPromise","ForwardErrors","errors","CALL_EXCEPTION","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","provider","start","done","error","normalizedTally","normalize","quorum","configs","tally","forEach","c","count","check","undefined","getProcessFunc","method","params","blockNumber","ceil","indexOf","_highestBlockNumber","tx","confirmations","includeTransactions","block","transactions","waitForSync","reject","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","blockTag","address","getStorageAt","position","blockHash","transaction","transactionHash","filter","fromBlock","toBlock","getLogs","throwError","UNKNOWN_ERROR","FallbackProvider","constructor","providers","checkNew","new","target","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","total","reduce","accum","networkOrReady","detectNetwork","all","getNetwork","perform","results","sendTransaction","signedTransaction","hash","getBlockNumber","processFunc","first","t0","inflightWeight","runner","rid","staller","listenerCount","emit","action","backend","request","waiting","push","race","code","errorCode","e","props","reason","message","SERVER_ERROR"],"sources":["E:\\6883proj\\6883project\\node_modules\\@ethersproject\\providers\\src.ts\\fallback-provider.ts"],"sourcesContent":["\"use strict\";\r\n\r\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { isHexString } from \"@ethersproject/bytes\";\r\nimport { Network } from \"@ethersproject/networks\";\r\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\r\nimport { shuffled } from \"@ethersproject/random\";\r\nimport { poll } from \"@ethersproject/web\";\r\n\r\nimport { BaseProvider } from \"./base-provider\";\r\nimport { isCommunityResource } from \"./formatter\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nfunction now() { return (new Date()).getTime(); }\r\n\r\n// Returns to network as long as all agree, or null if any is null.\r\n// Throws an error if any two networks do not match.\r\nfunction checkNetworks(networks: Array<Network>): Network {\r\n    let result = null;\r\n\r\n    for (let i = 0; i < networks.length; i++) {\r\n        const network = networks[i];\r\n\r\n        // Null! We do not know our network; bail.\r\n        if (network == null) { return null; }\r\n\r\n        if (result) {\r\n            // Make sure the network matches the previous networks\r\n            if (!(result.name === network.name && result.chainId === network.chainId &&\r\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\r\n\r\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\r\n           }\r\n        } else {\r\n            result = network;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction median(values: Array<number>, maxDelta?: number): number {\r\n    values = values.slice().sort();\r\n    const middle = Math.floor(values.length / 2);\r\n\r\n    // Odd length; take the middle\r\n    if (values.length % 2) {\r\n        return values[middle];\r\n    }\r\n\r\n    // Even length; take the average of the two middle\r\n    const a = values[middle - 1], b = values[middle];\r\n\r\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\r\n        return null;\r\n    }\r\n\r\n    return (a + b) / 2;\r\n}\r\n\r\nfunction serialize(value: any): string {\r\n    if (value === null) {\r\n        return \"null\";\r\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\r\n        return JSON.stringify(value);\r\n    } else if (typeof(value) === \"string\") {\r\n        return value;\r\n    } else if (BigNumber.isBigNumber(value)) {\r\n        return value.toString();\r\n    } else if (Array.isArray(value)) {\r\n        return JSON.stringify(value.map((i) => serialize(i)));\r\n    } else if (typeof(value) === \"object\") {\r\n        const keys = Object.keys(value);\r\n        keys.sort();\r\n        return \"{\" + keys.map((key) => {\r\n            let v = value[key];\r\n            if (typeof(v) === \"function\") {\r\n                v = \"[function]\";\r\n            } else {\r\n                v = serialize(v);\r\n            }\r\n            return JSON.stringify(key) + \":\" + v;\r\n        }).join(\",\") + \"}\";\r\n    }\r\n\r\n    throw new Error(\"unknown value type: \" + typeof(value));\r\n}\r\n\r\n// Next request ID to use for emitting debug info\r\nlet nextRid = 1;\r\n\r\n\r\nexport interface FallbackProviderConfig {\r\n    // The Provider\r\n    provider: Provider;\r\n\r\n    // The priority to favour this Provider; lower values are used first (higher priority)\r\n    priority?: number;\r\n\r\n    // Timeout before also triggering the next provider; this does not stop\r\n    // this provider and if its result comes back before a quorum is reached\r\n    // it will be incorporated into the vote\r\n    // - lower values will cause more network traffic but may result in a\r\n    //   faster result.\r\n    stallTimeout?: number;\r\n\r\n    // How much this provider contributes to the quorum; sometimes a specific\r\n    // provider may be more reliable or trustworthy than others, but usually\r\n    // this should be left as the default\r\n    weight?: number;\r\n};\r\n\r\n// A Staller is used to provide a delay to give a Provider a chance to response\r\n// before asking the next Provider to try.\r\ntype Staller = {\r\n    wait: (func: () => void) => Promise<void>\r\n    getPromise: () => Promise<void>,\r\n    cancel: () => void\r\n};\r\n\r\nfunction stall(duration: number): Staller {\r\n    let cancel: () => void = null;\r\n\r\n    let timer: NodeJS.Timer = null;\r\n    let promise = <Promise<void>>(new Promise((resolve) => {\r\n        cancel = function() {\r\n            if (timer) {\r\n                clearTimeout(timer);\r\n                timer = null;\r\n            }\r\n            resolve();\r\n        }\r\n        timer = setTimeout(cancel, duration);\r\n    }));\r\n\r\n    const wait = (func: () => void) => {\r\n        promise = promise.then(func);\r\n        return promise;\r\n    }\r\n\r\n    function getPromise(): Promise<void> {\r\n        return promise;\r\n    }\r\n\r\n    return { cancel, getPromise, wait };\r\n}\r\n\r\nconst ForwardErrors = [\r\n    Logger.errors.CALL_EXCEPTION,\r\n    Logger.errors.INSUFFICIENT_FUNDS,\r\n    Logger.errors.NONCE_EXPIRED,\r\n    Logger.errors.REPLACEMENT_UNDERPRICED,\r\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\r\n];\r\n\r\nconst ForwardProperties = [\r\n    \"address\",\r\n    \"args\",\r\n    \"errorArgs\",\r\n    \"errorSignature\",\r\n    \"method\",\r\n    \"transaction\",\r\n];\r\n\r\n\r\n// @TODO: Make this an object with staller and cancel built-in\r\ninterface RunningConfig extends FallbackProviderConfig {\r\n    start?: number;\r\n    done?: boolean;\r\n    cancelled?: boolean;\r\n    runner?: Promise<any>;\r\n    staller?: Staller;\r\n    result?: any;\r\n    error?: Error;\r\n};\r\n\r\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\r\n    const result: any = {\r\n        weight: config.weight\r\n    };\r\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\r\n    if (config.start) { result.start = config.start; }\r\n    if (now) { result.duration = (now - config.start); }\r\n    if (config.done) {\r\n        if (config.error) {\r\n            result.error = config.error;\r\n        } else {\r\n            result.result = config.result || null;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\r\n    return function(configs: Array<RunningConfig>): any {\r\n\r\n        // Count the votes for each result\r\n        const tally: { [ key: string]: { count: number, result: any } } = { };\r\n        configs.forEach((c) => {\r\n            const value = normalize(c.result);\r\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\r\n            tally[value].count++;\r\n        });\r\n\r\n        // Check for a quorum on any given result\r\n        const keys = Object.keys(tally);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const check = tally[keys[i]];\r\n            if (check.count >= quorum) {\r\n                return check.result;\r\n            }\r\n        }\r\n\r\n        // No quroum\r\n        return undefined;\r\n    }\r\n}\r\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\r\n\r\n    let normalize = serialize;\r\n\r\n    switch (method) {\r\n        case \"getBlockNumber\":\r\n            // Return the median value, unless there is (median + 1) is also\r\n            // present, in which case that is probably true and the median\r\n            // is going to be stale soon. In the event of a malicious node,\r\n            // the lie will be true soon enough.\r\n            return function(configs: Array<RunningConfig>): number {\r\n                const values = configs.map((c) => c.result);\r\n\r\n                // Get the median block number\r\n                let blockNumber = median(configs.map((c) => c.result), 2);\r\n                if (blockNumber == null) { return undefined; }\r\n\r\n                blockNumber = Math.ceil(blockNumber);\r\n\r\n                // If the next block height is present, its prolly safe to use\r\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\r\n\r\n                // Don't ever roll back the blockNumber\r\n                if (blockNumber >= provider._highestBlockNumber) {\r\n                    provider._highestBlockNumber = blockNumber;\r\n                }\r\n\r\n                return provider._highestBlockNumber;\r\n            };\r\n\r\n        case \"getGasPrice\":\r\n            // Return the middle (round index up) value, similar to median\r\n            // but do not average even entries and choose the higher.\r\n            // Malicious actors must compromise 50% of the nodes to lie.\r\n            return function(configs: Array<RunningConfig>): BigNumber {\r\n                const values = configs.map((c) => c.result);\r\n                values.sort();\r\n                return values[Math.floor(values.length / 2)];\r\n            }\r\n\r\n        case \"getEtherPrice\":\r\n            // Returns the median price. Malicious actors must compromise at\r\n            // least 50% of the nodes to lie (in a meaningful way).\r\n            return function(configs: Array<RunningConfig>): number {\r\n                return median(configs.map((c) => c.result));\r\n            }\r\n\r\n        // No additional normalizing required; serialize is enough\r\n        case \"getBalance\":\r\n        case \"getTransactionCount\":\r\n        case \"getCode\":\r\n        case \"getStorageAt\":\r\n        case \"call\":\r\n        case \"estimateGas\":\r\n        case \"getLogs\":\r\n            break;\r\n\r\n        // We drop the confirmations from transactions as it is approximate\r\n        case \"getTransaction\":\r\n        case \"getTransactionReceipt\":\r\n            normalize = function(tx: any): string {\r\n                if (tx == null) { return null; }\r\n\r\n                tx = shallowCopy(tx);\r\n                tx.confirmations = -1;\r\n                return serialize(tx);\r\n            }\r\n            break;\r\n\r\n        // We drop the confirmations from transactions as it is approximate\r\n        case \"getBlock\":\r\n            // We drop the confirmations from transactions as it is approximate\r\n            if (params.includeTransactions) {\r\n                normalize = function(block: BlockWithTransactions): string {\r\n                    if (block == null) { return null; }\r\n\r\n                    block = shallowCopy(block);\r\n                    block.transactions = block.transactions.map((tx) => {\r\n                        tx = shallowCopy(tx);\r\n                        tx.confirmations = -1;\r\n                        return tx;\r\n                    });\r\n                    return serialize(block);\r\n                };\r\n            } else {\r\n                normalize = function(block: Block): string {\r\n                    if (block == null) { return null; }\r\n                    return serialize(block);\r\n                }\r\n            }\r\n            break;\r\n\r\n        default:\r\n            throw new Error(\"unknown method: \" + method);\r\n    }\r\n\r\n    // Return the result if and only if the expected quorum is\r\n    // satisfied and agreed upon for the final result.\r\n    return normalizedTally(normalize, provider.quorum);\r\n\r\n}\r\n\r\n// If we are doing a blockTag query, we need to make sure the backend is\r\n// caught up to the FallbackProvider, before sending a request to it.\r\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\r\n    const provider = <BaseProvider>(config.provider);\r\n\r\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\r\n        return provider;\r\n    }\r\n\r\n    return poll(() => {\r\n        return new Promise((resolve, reject) => {\r\n            setTimeout(function() {\r\n\r\n                // We are synced\r\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\r\n\r\n                // We're done; just quit\r\n                if (config.cancelled) { return resolve(null); }\r\n\r\n                // Try again, next block\r\n                return resolve(undefined);\r\n            }, 0);\r\n        });\r\n    }, { oncePoll: provider });\r\n}\r\n\r\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\r\n    let provider = config.provider;\r\n\r\n    switch (method) {\r\n        case \"getBlockNumber\":\r\n        case \"getGasPrice\":\r\n            return provider[method]();\r\n        case \"getEtherPrice\":\r\n            if ((<any>provider).getEtherPrice) {\r\n                return (<any>provider).getEtherPrice();\r\n            }\r\n            break;\r\n        case \"getBalance\":\r\n        case \"getTransactionCount\":\r\n        case \"getCode\":\r\n            if (params.blockTag && isHexString(params.blockTag)) {\r\n                provider = await waitForSync(config, currentBlockNumber)\r\n            }\r\n            return provider[method](params.address, params.blockTag || \"latest\");\r\n        case \"getStorageAt\":\r\n            if (params.blockTag && isHexString(params.blockTag)) {\r\n                provider = await waitForSync(config, currentBlockNumber)\r\n            }\r\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\r\n        case \"getBlock\":\r\n            if (params.blockTag && isHexString(params.blockTag)) {\r\n                provider = await waitForSync(config, currentBlockNumber)\r\n            }\r\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\r\n        case \"call\":\r\n        case \"estimateGas\":\r\n            if (params.blockTag && isHexString(params.blockTag)) {\r\n                provider = await waitForSync(config, currentBlockNumber)\r\n            }\r\n            return provider[method](params.transaction);\r\n        case \"getTransaction\":\r\n        case \"getTransactionReceipt\":\r\n            return provider[method](params.transactionHash);\r\n        case \"getLogs\": {\r\n            let filter = params.filter;\r\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\r\n                provider = await waitForSync(config, currentBlockNumber)\r\n            }\r\n            return provider.getLogs(filter);\r\n        }\r\n    }\r\n\r\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\r\n        method: method,\r\n        params: params\r\n    });\r\n}\r\n\r\nexport class FallbackProvider extends BaseProvider {\r\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\r\n    readonly quorum: number;\r\n\r\n    // Due to the highly asyncronous nature of the blockchain, we need\r\n    // to make sure we never unroll the blockNumber due to our random\r\n    // sample of backends\r\n    _highestBlockNumber: number;\r\n\r\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\r\n        logger.checkNew(new.target, FallbackProvider);\r\n\r\n        if (providers.length === 0) {\r\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\r\n        }\r\n\r\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\r\n            if (Provider.isProvider(configOrProvider)) {\r\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\r\n                const priority = 1;\r\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\r\n            }\r\n\r\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\r\n\r\n            if (config.priority == null) { config.priority = 1; }\r\n            if (config.stallTimeout == null) {\r\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\r\n            }\r\n            if (config.weight == null) { config.weight = 1; }\r\n\r\n            const weight = config.weight;\r\n            if (weight % 1 || weight > 512 || weight < 1) {\r\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\r\n            }\r\n\r\n            return Object.freeze(config);\r\n        });\r\n\r\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\r\n\r\n        if (quorum == null) {\r\n            quorum = total / 2;\r\n        } else if (quorum > total) {\r\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\r\n        }\r\n\r\n        // Are all providers' networks are known\r\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\r\n\r\n        // Not all networks are known; we must stall\r\n        if (networkOrReady == null) {\r\n            networkOrReady = new Promise((resolve, reject) => {\r\n                setTimeout(() => {\r\n                    this.detectNetwork().then(resolve, reject);\r\n                }, 0);\r\n            });\r\n        }\r\n\r\n        super(networkOrReady);\r\n\r\n        // Preserve a copy, so we do not get mutated\r\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\r\n        defineReadOnly(this, \"quorum\", quorum);\r\n\r\n        this._highestBlockNumber = -1;\r\n    }\r\n\r\n    async detectNetwork(): Promise<Network> {\r\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\r\n        return checkNetworks(networks);\r\n    }\r\n\r\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\r\n        // Sending transactions is special; always broadcast it to all backends\r\n        if (method === \"sendTransaction\") {\r\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\r\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\r\n                    return result.hash;\r\n                }, (error) => {\r\n                    return error;\r\n                });\r\n            }));\r\n\r\n            // Any success is good enough (other errors are likely \"already seen\" errors\r\n            for (let i = 0; i < results.length; i++) {\r\n                const result = results[i];\r\n                if (typeof(result) === \"string\") { return result; }\r\n            }\r\n\r\n            // They were all an error; pick the first error\r\n            throw results[0];\r\n        }\r\n\r\n        // We need to make sure we are in sync with our backends, so we need\r\n        // to know this before we can make a lot of calls\r\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\r\n            await this.getBlockNumber();\r\n        }\r\n\r\n        const processFunc = getProcessFunc(this, method, params);\r\n\r\n        // Shuffle the providers and then sort them by their priority; we\r\n        // shallowCopy them since we will store the result in them too\r\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\r\n        configs.sort((a, b) => (a.priority - b.priority));\r\n\r\n        const currentBlockNumber = this._highestBlockNumber;\r\n\r\n        let i = 0;\r\n        let first = true;\r\n        while (true) {\r\n            const t0 = now();\r\n\r\n            // Compute the inflight weight (exclude anything past)\r\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\r\n                                        .reduce((accum, c) => (accum + c.weight), 0);\r\n\r\n            // Start running enough to meet quorum\r\n            while (inflightWeight < this.quorum && i < configs.length) {\r\n                const config = configs[i++];\r\n\r\n                const rid = nextRid++;\r\n\r\n                config.start = now();\r\n                config.staller = stall(config.stallTimeout);\r\n                config.staller.wait(() => { config.staller = null; });\r\n\r\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\r\n                    config.done = true;\r\n                    config.result = result;\r\n\r\n                    if (this.listenerCount(\"debug\")) {\r\n                        this.emit(\"debug\", {\r\n                            action: \"request\",\r\n                            rid: rid,\r\n                            backend: exposeDebugConfig(config, now()),\r\n                            request: { method: method, params: deepCopy(params) },\r\n                            provider: this\r\n                        });\r\n                     }\r\n\r\n                }, (error) => {\r\n                    config.done = true;\r\n                    config.error = error;\r\n\r\n                    if (this.listenerCount(\"debug\")) {\r\n                        this.emit(\"debug\", {\r\n                            action: \"request\",\r\n                            rid: rid,\r\n                            backend: exposeDebugConfig(config, now()),\r\n                            request: { method: method, params: deepCopy(params) },\r\n                            provider: this\r\n                        });\r\n                    }\r\n                });\r\n\r\n                if (this.listenerCount(\"debug\")) {\r\n                    this.emit(\"debug\", {\r\n                        action: \"request\",\r\n                        rid: rid,\r\n                        backend: exposeDebugConfig(config, null),\r\n                        request: { method: method, params: deepCopy(params) },\r\n                        provider: this\r\n                    });\r\n                }\r\n\r\n                inflightWeight += config.weight;\r\n            }\r\n\r\n            // Wait for anything meaningful to finish or stall out\r\n            const waiting: Array<Promise<any>> = [ ];\r\n            configs.forEach((c) => {\r\n                if (c.done || !c.runner) { return; }\r\n                waiting.push(c.runner);\r\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\r\n            });\r\n\r\n            if (waiting.length) { await Promise.race(waiting); }\r\n\r\n            // Check the quorum and process the results; the process function\r\n            // may additionally decide the quorum is not met\r\n            const results = configs.filter((c) => (c.done && c.error == null));\r\n            if (results.length >= this.quorum) {\r\n                const result = processFunc(results);\r\n                if (result !== undefined) {\r\n                    // Shut down any stallers\r\n                    configs.forEach(c => {\r\n                        if (c.staller) { c.staller.cancel(); }\r\n                        c.cancelled = true;\r\n                    });\r\n                    return result;\r\n                }\r\n                if (!first) { await stall(100).getPromise(); }\r\n                first = false;\r\n            }\r\n\r\n            // No result, check for errors that should be forwarded\r\n            const errors = configs.reduce((accum, c) => {\r\n                if (!c.done || c.error == null) { return accum; }\r\n\r\n                const code = (<any>(c.error)).code;\r\n                if (ForwardErrors.indexOf(code) >= 0) {\r\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\r\n                    accum[code].weight += c.weight;\r\n                }\r\n\r\n                return accum;\r\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\r\n\r\n            Object.keys(errors).forEach((errorCode: string) => {\r\n                const tally = errors[errorCode];\r\n                if (tally.weight < this.quorum) { return; }\r\n\r\n                // Shut down any stallers\r\n                configs.forEach(c => {\r\n                    if (c.staller) { c.staller.cancel(); }\r\n                    c.cancelled = true;\r\n                });\r\n\r\n                const e = <any>(tally.error);\r\n\r\n                const props: { [ name: string ]: any } = { };\r\n                ForwardProperties.forEach((name) => {\r\n                    if (e[name] == null) { return; }\r\n                    props[name] = e[name];\r\n                });\r\n\r\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\r\n            });\r\n\r\n            // All configs have run to completion; we will never get more data\r\n            if (configs.filter((c) => !c.done).length === 0) { break; }\r\n        }\r\n\r\n        // Shut down any stallers; shouldn't be any\r\n        configs.forEach(c => {\r\n            if (c.staller) { c.staller.cancel(); }\r\n            c.cancelled = true;\r\n        });\r\n\r\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\r\n            method: method,\r\n            params: params,\r\n            //results: configs.map((c) => c.result),\r\n            //errors: configs.map((c) => c.error),\r\n            results: configs.map((c) => exposeDebugConfig(c)),\r\n            provider: this\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}